---
title: 3.3 Pydantic and SQLAlchemy Integration
description: Seamlessly integrating Pydantic models with SQLAlchemy ORM models for data validation and serialization.
order: 3
---

# 3.3 Pydantic and SQLAlchemy Integration

Pydantic models are excellent for data validation and defining schemas for API requests and responses in FastAPI. SQLAlchemy models define the structure of your database tables and how data is persisted. Integrating these two allows for robust data handling from API input to database storage and back to API output.

## Converting SQLAlchemy Models to Pydantic Models

Pydantic models can be created from SQLAlchemy models, often using Pydantic's ORM mode. This allows Pydantic to read data directly from ORM objects.

### Example: Pydantic Model from SQLAlchemy Model

```python
from fastapi import FastAPI, Depends
from pydantic import BaseModel
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import sessionmaker, Session, DeclarativeBase

DATABASE_URL = "sqlite:///./test_pydantic_sqla.db"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

class Base(DeclarativeBase):
    pass

# SQLAlchemy model
class DBItem(Base):
    __tablename__ = "items_sqla_pydantic"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True)
    description = Column(String, index=True)

Base.metadata.create_all(bind=engine)

# Pydantic model for request body (creating an item)
class ItemCreate(BaseModel):
    name: str
    description: str | None = None

# Pydantic model for response (reading an item)
# This model will be populated from an SQLAlchemy model instance
class Item(BaseModel):
    id: int
    name: str
    description: str | None = None

    # Pydantic V2 ORM mode configuration
    class Config:
        from_attributes = True # Renamed from orm_mode in Pydantic V1

app = FastAPI()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.post("/items_pydantic/", response_model=Item)
def create_item_pydantic(item: ItemCreate, db: Session = Depends(get_db)):
    db_item = DBItem(name=item.name, description=item.description)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item # FastAPI will use Item (Pydantic model) with orm_mode to serialize db_item

@app.get("/items_pydantic/{item_id}", response_model=Item)
def read_item_pydantic(item_id: int, db: Session = Depends(get_db)):
    db_item = db.query(DBItem).filter(DBItem.id == item_id).first()
    if db_item is None:
        raise HTTPException(status_code=404, detail="Item not found")
    return db_item
```

### Key Points:
-   **`ItemCreate` (Pydantic Model)**: Used for validating the request body when creating a new item. It doesn't include `id` because that's usually generated by the database.
-   **`Item` (Pydantic Model)**: Used as the `response_model`. It includes `id` and other fields that are present in the `DBItem` SQLAlchemy model.
-   **`Config.from_attributes = True`**: This (or `orm_mode = True` in Pydantic V1) enables Pydantic to read data from SQLAlchemy model instances (attributes like `db_item.name` instead of dictionary keys like `db_item['name']`).
-   FastAPI uses the `response_model` to convert the SQLAlchemy `DBItem` instance into a Pydantic `Item` instance before sending the JSON response.

This integration simplifies data validation for incoming requests and data serialization for outgoing responses, keeping your API schemas consistent with your database models.

Placeholder content for "Pydantic and SQLAlchemy Integration". This section covers how to bridge Pydantic models (used by FastAPI for request/response validation and serialization) with SQLAlchemy ORM models (used for database interaction).
