// // src/app/(docs)/[...slug]/page.tsx
// import { notFound } from 'next/navigation';
// import { getDocumentContent, getAllMarkdownPaths, getPrevNextDocs } from '@/lib/docs';
// import type { Metadata } from 'next';
// import { siteConfig } from '@/config/site.config';
// import DocClientView from './doc-client-view';

// type Props = {
//   params: { slug: string[] };
// };

// // Metadata function needs to fetch data directly.
// // This will run on the server for each page request if dynamic.
// export async function generateMetadata({ params }: Props): Promise<Metadata> {
//   const doc = await getDocumentContent(params.slug.slice(1));
//   if (!doc) {
//     return {
//       title: `Not Found | ${siteConfig.name}`,
//       description: 'The page you are looking for does not exist.',
//     };
//   }
//   return {
//     title: `${doc.title} | ${siteConfig.name}`,
//     description: doc.description || siteConfig.description, 
//     openGraph: {
//         title: `${doc.title} | ${siteConfig.name}`,
//         description: doc.description || siteConfig.description,
//         url: `${siteConfig.url}/docs/${params.slug.join('/')}`, 
//     },
//     twitter: {
//         title: `${doc.title} | ${siteConfig.name}`,
//         description: doc.description || siteConfig.description,
//     }
//   };
// }


// // This function generates the static paths for all documentation pages.
// // It helps Next.js know which pages to pre-render at build time.
// export async function generateStaticParams() {
//   const paths = await getAllMarkdownPaths();
//   return paths.map((slugArray) => ({
//     slug: slugArray,
//   }));
// }

// // This ensures that if a path is not generated by generateStaticParams,
// // Next.js will attempt to render it dynamically on the server (SSR).
// // If it still can't be found, it will 404.
// export const dynamic = 'force-dynamic'; 

// // This is the main page component for a documentation page.
// // It fetches the content and renders it.
// export default async function Page({ params }: Props) {
//   const doc = await getDocumentContent(params.slug.slice(1));
  
//   if (!doc) {
//     notFound();
//   }

//   const { prev: prevDoc, next: nextDoc } = await getPrevNextDocs(params.slug.slice(1));

//   return <DocClientView initialDoc={doc} params={params} prevDoc={prevDoc} nextDoc={nextDoc} />;
// }

// src/app/(docs)/[...slug]/page.tsx
import { notFound } from 'next/navigation';
import { getDocumentContent, getAllMarkdownPaths, getPrevNextDocs } from '@/lib/docs';
import type { Metadata } from 'next';
import { siteConfig } from '@/config/site.config';
import DocClientView from './doc-client-view';

type Props = {
  params: Promise<{ slug: string[] }>;
};

// Metadata function
export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const resolvedParams = await params; // Await the params Promise
  const doc = await getDocumentContent(resolvedParams.slug.slice(1));
  if (!doc) {
    return {
      title: `Not Found | ${siteConfig.name}`,
      description: 'The page you are looking for does not exist.',
    };
  }
  return {
    title: `${doc.title} | ${siteConfig.name}`,
    description: doc.description || siteConfig.description,
    openGraph: {
      title: `${doc.title} | ${siteConfig.name}`,
      description: doc.description || siteConfig.description,
      url: `${siteConfig.url}/docs/${resolvedParams.slug.join('/')}`,
    },
    twitter: {
      title: `${doc.title} | ${siteConfig.name}`,
      description: doc.description || siteConfig.description,
    },
  };
}

// Static params generation
export async function generateStaticParams() {
  const paths = await getAllMarkdownPaths();
  return paths.map((slugArray) => ({
    slug: slugArray,
  }));
}

export const dynamic = 'force-dynamic';

// Page component
export default async function Page({ params }: Props) {
  const resolvedParams = await params; // Await the params Promise
  const doc = await getDocumentContent(resolvedParams.slug.slice(1));

  if (!doc) {
    notFound();
  }

  const { prev: prevDoc, next: nextDoc } = await getPrevNextDocs(resolvedParams.slug.slice(1));

  return <DocClientView initialDoc={doc} params={resolvedParams} prevDoc={prevDoc} nextDoc={nextDoc} />;
}